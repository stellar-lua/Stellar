"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[639],{65200:e=>{e.exports=JSON.parse('{"functions":[{"name":"ObserveSignal","desc":"Observes a RemoteEvent","params":[{"name":"name","desc":"","lua_type":"string"},{"name":"func","desc":"","lua_type":"(player: Player, ...any) -> ()"}],"returns":[{"desc":"","lua_type":"RBXScriptConnection\\n"}],"function_type":"method","source":{"line":27,"path":"src/Core/Shared/Network.lua"}},{"name":"Signal","desc":"Signals the server if run on the client, and vice versa","params":[{"name":"name","desc":"","lua_type":"string"},{"name":"...","desc":"","lua_type":"any"}],"returns":[],"function_type":"method","source":{"line":42,"path":"src/Core/Shared/Network.lua"}},{"name":"SignalAll","desc":"Signals all clients","params":[{"name":"name","desc":"","lua_type":"string"},{"name":"...","desc":"","lua_type":"any"}],"returns":[],"function_type":"method","source":{"line":54,"path":"src/Core/Shared/Network.lua"}},{"name":"SignalAsync","desc":"Signals and yields for response","params":[{"name":"name","desc":"","lua_type":"string"},{"name":"...","desc":"","lua_type":"any"}],"returns":[],"function_type":"method","source":{"line":63,"path":"src/Core/Shared/Network.lua"}},{"name":"Invoke","desc":"Invokes the server","params":[{"name":"name","desc":"","lua_type":"string"},{"name":"...","desc":"","lua_type":"any"}],"returns":[{"desc":"","lua_type":"any\\n"}],"function_type":"method","errors":[{"lua_type":"\\"InvokeClient\\"","desc":"Invoking the client is not advised or supported with this module"}],"source":{"line":69,"path":"src/Core/Shared/Network.lua"}},{"name":"OnInvoke","desc":"Sets the function for handling invoke requests","params":[{"name":"name","desc":"","lua_type":"string"},{"name":"func","desc":"","lua_type":"(player: Player, ...any) -> ()"}],"returns":[],"function_type":"method","source":{"line":118,"path":"src/Core/Shared/Network.lua"}},{"name":"GetEndpoint","desc":"Used internally for getting remotes.\\nYou should use this too if you need to use the physical remote as they are named GUIDs after first found on client.\\nThis practice, whilst not completely solving remote tampering, will make it slightly harder.","params":[{"name":"name","desc":"","lua_type":"string"},{"name":"remote","desc":"","lua_type":"Endpoint"}],"returns":[{"desc":"","lua_type":"Remote\\n"}],"function_type":"method","source":{"line":139,"path":"src/Core/Shared/Network.lua"}}],"properties":[],"types":[],"name":"Network","desc":"Network handles the creation of RemoteEvents and RemoteFunctions.\\n\\n:::caution\\nIf the client attempts to connect to an endpoint which has not yet been referenced on the server, it will yield for 10 seconds and then drop the request.\\nIf the server does not reference the endpoint when the server starts, you must \\"Reserve\\" it on startup.\\n:::","source":{"line":11,"path":"src/Core/Shared/Network.lua"}}')}}]);